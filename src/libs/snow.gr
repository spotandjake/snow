module Snow

from "runtime/dataStructures" include DataStructures
from "runtime/unsafe/wasmi32" include WasmI32
from "runtime/unsafe/wasmi64" include WasmI64
from "runtime/unsafe/wasmf32" include WasmF32
from "runtime/unsafe/wasmf64" include WasmF64
from "runtime/unsafe/memory" include Memory
from "int32" include Int32
from "int64" include Int64
from "char" include Char
from "list" include List

@unsafe
let _RET_AREA = Memory.malloc(28n)

@unsafe
provide let cabi_realloc = (originalPtr: WasmI32, originalSize: WasmI32, alignment: WasmI32, newSize: WasmI32) => {
  if (WasmI32.eqz(originalPtr)) {
    Memory.malloc(newSize)
  } else {
    let newPtr = Memory.malloc(newSize)
    let amt = if (WasmI32.(<)(originalSize, newSize)) originalSize else newSize
    Memory.copy(newPtr, originalPtr, amt)
    Memory.free(originalPtr)
    newPtr
  }
}

provide record Resource<a> {
  mut handle: Int32,
  rep: a
}

provide record TextRange {
  start: Uint32,
  end: Uint32,
}
provide enum SyntaxToken {
  TokenComment,
  TokenError,
  TokenWhitespace,
  TokenAssert,
  TokenElse,
  TokenIf,
  TokenIn,
  TokenInherit,
  TokenLet,
  TokenOr,
  TokenRec,
  TokenThen,
  TokenWith,
  TokenLBrace,
  TokenRBrace,
  TokenLBrack,
  TokenRBrack,
  TokenAssign,
  TokenAt,
  TokenColon,
  TokenComma,
  TokenDot,
  TokenEllipsis,
  TokenQuestion,
  TokenSemicolon,
  TokenLParen,
  TokenRParen,
  TokenConcat,
  TokenInvert,
  TokenUpdate,
  TokenAdd,
  TokenSub,
  TokenMul,
  TokenDiv,
  TokenAndAnd,
  TokenEqual,
  TokenImplication,
  TokenLess,
  TokenLessOrEq,
  TokenMore,
  TokenMoreOrEq,
  TokenNotEqual,
  TokenOrOr,
  TokenFloat,
  TokenIdent,
  TokenInteger,
  TokenInterpolEnd,
  TokenInterpolStart,
  TokenPath,
  TokenUri,
  TokenStringContent,
  TokenStringEnd,
  TokenStringStart,
  NodeApply,
  NodeAssert,
  NodeAttrpath,
  NodeDynamic,
  NodeError,
  NodeIdent,
  NodeIfElse,
  NodeSelect,
  NodeInherit,
  NodeInheritFrom,
  NodeString,
  NodeInterpol,
  NodeLambda,
  NodeIdentParam,
  NodeLegacyLet,
  NodeLetIn,
  NodeList,
  NodeBinOp,
  NodeParen,
  NodePattern,
  NodePatBind,
  NodePatEntry,
  NodeRoot,
  NodeAttrSet,
  NodeAttrpathValue,
  NodeUnaryOp,
  NodeLiteral,
  NodeWith,
  NodePath,
  NodeHasAttr,
  Last,
}
provide record Apply {
  handle: Int32
}
provide record Assert {
  handle: Int32
}
provide record IfElse {
  handle: Int32
}
provide record AttrSet {
  handle: Int32
}
provide enum NixExpr {
  Apply(Apply),
  Assert(Assert),
  Error,
  IfElse(IfElse),
  Select,
  Str,
  Path,
  Literal,
  Lambda,
  LegacyLet,
  LetIn,
  List,
  BinOp,
  Paren,
  Root,
  AttrSet(AttrSet),
  UnaryOp,
  Ident,
  With,
  HasAttr,
  InvalidNode,
}
provide enum NixParseError {
  Unexpected(TextRange),
  UnexpectedExtra(TextRange),
  UnexpectedWanted((SyntaxToken, TextRange, List<SyntaxToken>)),
  UnexpectedDoubleBind(TextRange),
  UnexpectedEof,
  UnexpectedEofWanted(List<SyntaxToken>),
  DuplicatedArgs((TextRange, String)),
  RecursionLimitExceeded,
  Unknown,
}


provide module Nix {

  @externalName("parse")
  foreign wasm wit_bindgen_parse: (WasmI32, WasmI32, WasmI32) => Void from "spotandjake:snow/nix"

  @unsafe
  provide let parse: (String) => Result<NixExpr, NixParseError> = (nixSource) => {
    let vec_list_canon_lower = nixSource
    let ptr_list_canon_lower = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower), 8n)
    let len_list_canon_lower = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower), 4n)
    wit_bindgen_parse(ptr_list_canon_lower, len_list_canon_lower, _RET_AREA)
    match (WasmI32.load8U(_RET_AREA, 0n)) {
      0n => {
        
        Ok(match (WasmI32.load8U(_RET_AREA, 4n)) {
          0n => {
            let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 8n))),}: Apply
            Apply(handle_lift)
          },
          1n => {
            let handle_lift0 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 8n))),}: Assert
            Assert(handle_lift0)
          },
          2n => {
            Error
          },
          3n => {
            let handle_lift1 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 8n))),}: IfElse
            IfElse(handle_lift1)
          },
          4n => {
            Select
          },
          5n => {
            Str
          },
          6n => {
            Path
          },
          7n => {
            Literal
          },
          8n => {
            Lambda
          },
          9n => {
            LegacyLet
          },
          10n => {
            LetIn
          },
          11n => {
            List
          },
          12n => {
            BinOp
          },
          13n => {
            Paren
          },
          14n => {
            Root
          },
          15n => {
            let handle_lift2 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 8n))),}: AttrSet
            AttrSet(handle_lift2)
          },
          16n => {
            UnaryOp
          },
          17n => {
            Ident
          },
          18n => {
            With
          },
          19n => {
            HasAttr
          },
          _ => {
            InvalidNode
          },
        })
      },
      1n => {
        
        Err(match (WasmI32.load8U(_RET_AREA, 4n)) {
          0n => {
            Unexpected({ start: WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 8n))): Uint32, end: WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 12n))): Uint32 })
          },
          1n => {
            UnexpectedExtra({ start: WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 8n))): Uint32, end: WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 12n))): Uint32 })
          },
          2n => {
            let base_list_lift = WasmI32.load(_RET_AREA, 20n)
            let len_list_lift = WasmI32.load(_RET_AREA, 24n)
            let mut result_list_lift = []
            Memory.incRef(WasmI32.fromGrain(result_list_lift))
            for (let mut i = WasmI32.(-)(len_list_lift, 1n); WasmI32.gtU(i, 0n); i = WasmI32.(-)(i, 1n)) {
              let base = WasmI32.(+)(base_list_lift, WasmI32.(*)(i, 1n))
              result_list_lift = [match (WasmI32.load8U(base, 0n)) {
                0n => {
                  TokenComment
                },
                1n => {
                  TokenError
                },
                2n => {
                  TokenWhitespace
                },
                3n => {
                  TokenAssert
                },
                4n => {
                  TokenElse
                },
                5n => {
                  TokenIf
                },
                6n => {
                  TokenIn
                },
                7n => {
                  TokenInherit
                },
                8n => {
                  TokenLet
                },
                9n => {
                  TokenOr
                },
                10n => {
                  TokenRec
                },
                11n => {
                  TokenThen
                },
                12n => {
                  TokenWith
                },
                13n => {
                  TokenLBrace
                },
                14n => {
                  TokenRBrace
                },
                15n => {
                  TokenLBrack
                },
                16n => {
                  TokenRBrack
                },
                17n => {
                  TokenAssign
                },
                18n => {
                  TokenAt
                },
                19n => {
                  TokenColon
                },
                20n => {
                  TokenComma
                },
                21n => {
                  TokenDot
                },
                22n => {
                  TokenEllipsis
                },
                23n => {
                  TokenQuestion
                },
                24n => {
                  TokenSemicolon
                },
                25n => {
                  TokenLParen
                },
                26n => {
                  TokenRParen
                },
                27n => {
                  TokenConcat
                },
                28n => {
                  TokenInvert
                },
                29n => {
                  TokenUpdate
                },
                30n => {
                  TokenAdd
                },
                31n => {
                  TokenSub
                },
                32n => {
                  TokenMul
                },
                33n => {
                  TokenDiv
                },
                34n => {
                  TokenAndAnd
                },
                35n => {
                  TokenEqual
                },
                36n => {
                  TokenImplication
                },
                37n => {
                  TokenLess
                },
                38n => {
                  TokenLessOrEq
                },
                39n => {
                  TokenMore
                },
                40n => {
                  TokenMoreOrEq
                },
                41n => {
                  TokenNotEqual
                },
                42n => {
                  TokenOrOr
                },
                43n => {
                  TokenFloat
                },
                44n => {
                  TokenIdent
                },
                45n => {
                  TokenInteger
                },
                46n => {
                  TokenInterpolEnd
                },
                47n => {
                  TokenInterpolStart
                },
                48n => {
                  TokenPath
                },
                49n => {
                  TokenUri
                },
                50n => {
                  TokenStringContent
                },
                51n => {
                  TokenStringEnd
                },
                52n => {
                  TokenStringStart
                },
                53n => {
                  NodeApply
                },
                54n => {
                  NodeAssert
                },
                55n => {
                  NodeAttrpath
                },
                56n => {
                  NodeDynamic
                },
                57n => {
                  NodeError
                },
                58n => {
                  NodeIdent
                },
                59n => {
                  NodeIfElse
                },
                60n => {
                  NodeSelect
                },
                61n => {
                  NodeInherit
                },
                62n => {
                  NodeInheritFrom
                },
                63n => {
                  NodeString
                },
                64n => {
                  NodeInterpol
                },
                65n => {
                  NodeLambda
                },
                66n => {
                  NodeIdentParam
                },
                67n => {
                  NodeLegacyLet
                },
                68n => {
                  NodeLetIn
                },
                69n => {
                  NodeList
                },
                70n => {
                  NodeBinOp
                },
                71n => {
                  NodeParen
                },
                72n => {
                  NodePattern
                },
                73n => {
                  NodePatBind
                },
                74n => {
                  NodePatEntry
                },
                75n => {
                  NodeRoot
                },
                76n => {
                  NodeAttrSet
                },
                77n => {
                  NodeAttrpathValue
                },
                78n => {
                  NodeUnaryOp
                },
                79n => {
                  NodeLiteral
                },
                80n => {
                  NodeWith
                },
                81n => {
                  NodePath
                },
                82n => {
                  NodeHasAttr
                },
                _ => {
                  Last
                },
              }, ...result_list_lift]
            }
            UnexpectedWanted((match (WasmI32.load8U(_RET_AREA, 8n)) {
              0n => {
                TokenComment
              },
              1n => {
                TokenError
              },
              2n => {
                TokenWhitespace
              },
              3n => {
                TokenAssert
              },
              4n => {
                TokenElse
              },
              5n => {
                TokenIf
              },
              6n => {
                TokenIn
              },
              7n => {
                TokenInherit
              },
              8n => {
                TokenLet
              },
              9n => {
                TokenOr
              },
              10n => {
                TokenRec
              },
              11n => {
                TokenThen
              },
              12n => {
                TokenWith
              },
              13n => {
                TokenLBrace
              },
              14n => {
                TokenRBrace
              },
              15n => {
                TokenLBrack
              },
              16n => {
                TokenRBrack
              },
              17n => {
                TokenAssign
              },
              18n => {
                TokenAt
              },
              19n => {
                TokenColon
              },
              20n => {
                TokenComma
              },
              21n => {
                TokenDot
              },
              22n => {
                TokenEllipsis
              },
              23n => {
                TokenQuestion
              },
              24n => {
                TokenSemicolon
              },
              25n => {
                TokenLParen
              },
              26n => {
                TokenRParen
              },
              27n => {
                TokenConcat
              },
              28n => {
                TokenInvert
              },
              29n => {
                TokenUpdate
              },
              30n => {
                TokenAdd
              },
              31n => {
                TokenSub
              },
              32n => {
                TokenMul
              },
              33n => {
                TokenDiv
              },
              34n => {
                TokenAndAnd
              },
              35n => {
                TokenEqual
              },
              36n => {
                TokenImplication
              },
              37n => {
                TokenLess
              },
              38n => {
                TokenLessOrEq
              },
              39n => {
                TokenMore
              },
              40n => {
                TokenMoreOrEq
              },
              41n => {
                TokenNotEqual
              },
              42n => {
                TokenOrOr
              },
              43n => {
                TokenFloat
              },
              44n => {
                TokenIdent
              },
              45n => {
                TokenInteger
              },
              46n => {
                TokenInterpolEnd
              },
              47n => {
                TokenInterpolStart
              },
              48n => {
                TokenPath
              },
              49n => {
                TokenUri
              },
              50n => {
                TokenStringContent
              },
              51n => {
                TokenStringEnd
              },
              52n => {
                TokenStringStart
              },
              53n => {
                NodeApply
              },
              54n => {
                NodeAssert
              },
              55n => {
                NodeAttrpath
              },
              56n => {
                NodeDynamic
              },
              57n => {
                NodeError
              },
              58n => {
                NodeIdent
              },
              59n => {
                NodeIfElse
              },
              60n => {
                NodeSelect
              },
              61n => {
                NodeInherit
              },
              62n => {
                NodeInheritFrom
              },
              63n => {
                NodeString
              },
              64n => {
                NodeInterpol
              },
              65n => {
                NodeLambda
              },
              66n => {
                NodeIdentParam
              },
              67n => {
                NodeLegacyLet
              },
              68n => {
                NodeLetIn
              },
              69n => {
                NodeList
              },
              70n => {
                NodeBinOp
              },
              71n => {
                NodeParen
              },
              72n => {
                NodePattern
              },
              73n => {
                NodePatBind
              },
              74n => {
                NodePatEntry
              },
              75n => {
                NodeRoot
              },
              76n => {
                NodeAttrSet
              },
              77n => {
                NodeAttrpathValue
              },
              78n => {
                NodeUnaryOp
              },
              79n => {
                NodeLiteral
              },
              80n => {
                NodeWith
              },
              81n => {
                NodePath
              },
              82n => {
                NodeHasAttr
              },
              _ => {
                Last
              },
            }, { start: WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 12n))): Uint32, end: WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 16n))): Uint32 }, result_list_lift))
          },
          3n => {
            UnexpectedDoubleBind({ start: WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 8n))): Uint32, end: WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 12n))): Uint32 })
          },
          4n => {
            UnexpectedEof
          },
          5n => {
            let base_list_lift3 = WasmI32.load(_RET_AREA, 8n)
            let len_list_lift3 = WasmI32.load(_RET_AREA, 12n)
            let mut result_list_lift3 = []
            Memory.incRef(WasmI32.fromGrain(result_list_lift3))
            for (let mut i = WasmI32.(-)(len_list_lift3, 1n); WasmI32.gtU(i, 0n); i = WasmI32.(-)(i, 1n)) {
              let base = WasmI32.(+)(base_list_lift3, WasmI32.(*)(i, 1n))
              result_list_lift3 = [match (WasmI32.load8U(base, 0n)) {
                0n => {
                  TokenComment
                },
                1n => {
                  TokenError
                },
                2n => {
                  TokenWhitespace
                },
                3n => {
                  TokenAssert
                },
                4n => {
                  TokenElse
                },
                5n => {
                  TokenIf
                },
                6n => {
                  TokenIn
                },
                7n => {
                  TokenInherit
                },
                8n => {
                  TokenLet
                },
                9n => {
                  TokenOr
                },
                10n => {
                  TokenRec
                },
                11n => {
                  TokenThen
                },
                12n => {
                  TokenWith
                },
                13n => {
                  TokenLBrace
                },
                14n => {
                  TokenRBrace
                },
                15n => {
                  TokenLBrack
                },
                16n => {
                  TokenRBrack
                },
                17n => {
                  TokenAssign
                },
                18n => {
                  TokenAt
                },
                19n => {
                  TokenColon
                },
                20n => {
                  TokenComma
                },
                21n => {
                  TokenDot
                },
                22n => {
                  TokenEllipsis
                },
                23n => {
                  TokenQuestion
                },
                24n => {
                  TokenSemicolon
                },
                25n => {
                  TokenLParen
                },
                26n => {
                  TokenRParen
                },
                27n => {
                  TokenConcat
                },
                28n => {
                  TokenInvert
                },
                29n => {
                  TokenUpdate
                },
                30n => {
                  TokenAdd
                },
                31n => {
                  TokenSub
                },
                32n => {
                  TokenMul
                },
                33n => {
                  TokenDiv
                },
                34n => {
                  TokenAndAnd
                },
                35n => {
                  TokenEqual
                },
                36n => {
                  TokenImplication
                },
                37n => {
                  TokenLess
                },
                38n => {
                  TokenLessOrEq
                },
                39n => {
                  TokenMore
                },
                40n => {
                  TokenMoreOrEq
                },
                41n => {
                  TokenNotEqual
                },
                42n => {
                  TokenOrOr
                },
                43n => {
                  TokenFloat
                },
                44n => {
                  TokenIdent
                },
                45n => {
                  TokenInteger
                },
                46n => {
                  TokenInterpolEnd
                },
                47n => {
                  TokenInterpolStart
                },
                48n => {
                  TokenPath
                },
                49n => {
                  TokenUri
                },
                50n => {
                  TokenStringContent
                },
                51n => {
                  TokenStringEnd
                },
                52n => {
                  TokenStringStart
                },
                53n => {
                  NodeApply
                },
                54n => {
                  NodeAssert
                },
                55n => {
                  NodeAttrpath
                },
                56n => {
                  NodeDynamic
                },
                57n => {
                  NodeError
                },
                58n => {
                  NodeIdent
                },
                59n => {
                  NodeIfElse
                },
                60n => {
                  NodeSelect
                },
                61n => {
                  NodeInherit
                },
                62n => {
                  NodeInheritFrom
                },
                63n => {
                  NodeString
                },
                64n => {
                  NodeInterpol
                },
                65n => {
                  NodeLambda
                },
                66n => {
                  NodeIdentParam
                },
                67n => {
                  NodeLegacyLet
                },
                68n => {
                  NodeLetIn
                },
                69n => {
                  NodeList
                },
                70n => {
                  NodeBinOp
                },
                71n => {
                  NodeParen
                },
                72n => {
                  NodePattern
                },
                73n => {
                  NodePatBind
                },
                74n => {
                  NodePatEntry
                },
                75n => {
                  NodeRoot
                },
                76n => {
                  NodeAttrSet
                },
                77n => {
                  NodeAttrpathValue
                },
                78n => {
                  NodeUnaryOp
                },
                79n => {
                  NodeLiteral
                },
                80n => {
                  NodeWith
                },
                81n => {
                  NodePath
                },
                82n => {
                  NodeHasAttr
                },
                _ => {
                  Last
                },
              }, ...result_list_lift3]
            }
            UnexpectedEofWanted(result_list_lift3)
          },
          6n => {
            let len_string_lift = WasmI32.load(_RET_AREA, 20n)
            let str_string_lift = DataStructures.allocateString(len_string_lift)
            Memory.copy(WasmI32.(+)(str_string_lift, 8n), WasmI32.load(_RET_AREA, 16n), len_string_lift)
            let str_string_lift = WasmI32.toGrain(str_string_lift): String
            DuplicatedArgs(({ start: WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 8n))): Uint32, end: WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 12n))): Uint32 }, str_string_lift))
          },
          7n => {
            RecursionLimitExceeded
          },
          _ => {
            Unknown
          },
        })
      },
      _ => fail "invalid enum discriminant",
    }
  }


  provide module Apply {
    @externalName("[constructor]apply")
    foreign wasm wit_bindgen_constructorApply: (WasmI32, WasmI32, WasmI32, WasmI32) => WasmI32 from "spotandjake:snow/nix"

    @unsafe
    provide let constructor: (NixExpr, NixExpr) => Apply = (arg, lambda) => {
      let mut resultvariant_lower_0 = 0n
      let mut resultvariant_lower_1 = 0n
      match (arg) {
        Apply(e) => {
          resultvariant_lower_0 = 0n
          resultvariant_lower_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Assert(e) => {
          resultvariant_lower_0 = 1n
          resultvariant_lower_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Error => {
          resultvariant_lower_0 = 2n
          resultvariant_lower_1 = 0n
        },
        IfElse(e) => {
          resultvariant_lower_0 = 3n
          resultvariant_lower_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Select => {
          resultvariant_lower_0 = 4n
          resultvariant_lower_1 = 0n
        },
        Str => {
          resultvariant_lower_0 = 5n
          resultvariant_lower_1 = 0n
        },
        Path => {
          resultvariant_lower_0 = 6n
          resultvariant_lower_1 = 0n
        },
        Literal => {
          resultvariant_lower_0 = 7n
          resultvariant_lower_1 = 0n
        },
        Lambda => {
          resultvariant_lower_0 = 8n
          resultvariant_lower_1 = 0n
        },
        LegacyLet => {
          resultvariant_lower_0 = 9n
          resultvariant_lower_1 = 0n
        },
        LetIn => {
          resultvariant_lower_0 = 10n
          resultvariant_lower_1 = 0n
        },
        List => {
          resultvariant_lower_0 = 11n
          resultvariant_lower_1 = 0n
        },
        BinOp => {
          resultvariant_lower_0 = 12n
          resultvariant_lower_1 = 0n
        },
        Paren => {
          resultvariant_lower_0 = 13n
          resultvariant_lower_1 = 0n
        },
        Root => {
          resultvariant_lower_0 = 14n
          resultvariant_lower_1 = 0n
        },
        AttrSet(e) => {
          resultvariant_lower_0 = 15n
          resultvariant_lower_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        UnaryOp => {
          resultvariant_lower_0 = 16n
          resultvariant_lower_1 = 0n
        },
        Ident => {
          resultvariant_lower_0 = 17n
          resultvariant_lower_1 = 0n
        },
        With => {
          resultvariant_lower_0 = 18n
          resultvariant_lower_1 = 0n
        },
        HasAttr => {
          resultvariant_lower_0 = 19n
          resultvariant_lower_1 = 0n
        },
        InvalidNode => {
          resultvariant_lower_0 = 20n
          resultvariant_lower_1 = 0n
        },
      }
      let mut resultvariant_lower0_0 = 0n
      let mut resultvariant_lower0_1 = 0n
      match (lambda) {
        Apply(e) => {
          resultvariant_lower0_0 = 0n
          resultvariant_lower0_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Assert(e) => {
          resultvariant_lower0_0 = 1n
          resultvariant_lower0_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Error => {
          resultvariant_lower0_0 = 2n
          resultvariant_lower0_1 = 0n
        },
        IfElse(e) => {
          resultvariant_lower0_0 = 3n
          resultvariant_lower0_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Select => {
          resultvariant_lower0_0 = 4n
          resultvariant_lower0_1 = 0n
        },
        Str => {
          resultvariant_lower0_0 = 5n
          resultvariant_lower0_1 = 0n
        },
        Path => {
          resultvariant_lower0_0 = 6n
          resultvariant_lower0_1 = 0n
        },
        Literal => {
          resultvariant_lower0_0 = 7n
          resultvariant_lower0_1 = 0n
        },
        Lambda => {
          resultvariant_lower0_0 = 8n
          resultvariant_lower0_1 = 0n
        },
        LegacyLet => {
          resultvariant_lower0_0 = 9n
          resultvariant_lower0_1 = 0n
        },
        LetIn => {
          resultvariant_lower0_0 = 10n
          resultvariant_lower0_1 = 0n
        },
        List => {
          resultvariant_lower0_0 = 11n
          resultvariant_lower0_1 = 0n
        },
        BinOp => {
          resultvariant_lower0_0 = 12n
          resultvariant_lower0_1 = 0n
        },
        Paren => {
          resultvariant_lower0_0 = 13n
          resultvariant_lower0_1 = 0n
        },
        Root => {
          resultvariant_lower0_0 = 14n
          resultvariant_lower0_1 = 0n
        },
        AttrSet(e) => {
          resultvariant_lower0_0 = 15n
          resultvariant_lower0_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        UnaryOp => {
          resultvariant_lower0_0 = 16n
          resultvariant_lower0_1 = 0n
        },
        Ident => {
          resultvariant_lower0_0 = 17n
          resultvariant_lower0_1 = 0n
        },
        With => {
          resultvariant_lower0_0 = 18n
          resultvariant_lower0_1 = 0n
        },
        HasAttr => {
          resultvariant_lower0_0 = 19n
          resultvariant_lower0_1 = 0n
        },
        InvalidNode => {
          resultvariant_lower0_0 = 20n
          resultvariant_lower0_1 = 0n
        },
      }
      let ret = wit_bindgen_constructorApply(resultvariant_lower_0, resultvariant_lower_1, resultvariant_lower0_0, resultvariant_lower0_1)
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: Apply
      handle_lift
    }


    @externalName("[method]apply.get-argument")
    foreign wasm wit_bindgen_methodApply_getArgument: (WasmI32, WasmI32) => Void from "spotandjake:snow/nix"

    @unsafe
    provide let getArgument: (Apply) => NixExpr = (self) => {
      wit_bindgen_methodApply_getArgument(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: Apply
          Apply(handle_lift)
        },
        1n => {
          let handle_lift0 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: Assert
          Assert(handle_lift0)
        },
        2n => {
          Error
        },
        3n => {
          let handle_lift1 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: IfElse
          IfElse(handle_lift1)
        },
        4n => {
          Select
        },
        5n => {
          Str
        },
        6n => {
          Path
        },
        7n => {
          Literal
        },
        8n => {
          Lambda
        },
        9n => {
          LegacyLet
        },
        10n => {
          LetIn
        },
        11n => {
          List
        },
        12n => {
          BinOp
        },
        13n => {
          Paren
        },
        14n => {
          Root
        },
        15n => {
          let handle_lift2 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: AttrSet
          AttrSet(handle_lift2)
        },
        16n => {
          UnaryOp
        },
        17n => {
          Ident
        },
        18n => {
          With
        },
        19n => {
          HasAttr
        },
        _ => {
          InvalidNode
        },
      }
    }


    @externalName("[method]apply.get-lambda")
    foreign wasm wit_bindgen_methodApply_getLambda: (WasmI32, WasmI32) => Void from "spotandjake:snow/nix"

    @unsafe
    provide let getLambda: (Apply) => NixExpr = (self) => {
      wit_bindgen_methodApply_getLambda(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: Apply
          Apply(handle_lift)
        },
        1n => {
          let handle_lift0 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: Assert
          Assert(handle_lift0)
        },
        2n => {
          Error
        },
        3n => {
          let handle_lift1 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: IfElse
          IfElse(handle_lift1)
        },
        4n => {
          Select
        },
        5n => {
          Str
        },
        6n => {
          Path
        },
        7n => {
          Literal
        },
        8n => {
          Lambda
        },
        9n => {
          LegacyLet
        },
        10n => {
          LetIn
        },
        11n => {
          List
        },
        12n => {
          BinOp
        },
        13n => {
          Paren
        },
        14n => {
          Root
        },
        15n => {
          let handle_lift2 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: AttrSet
          AttrSet(handle_lift2)
        },
        16n => {
          UnaryOp
        },
        17n => {
          Ident
        },
        18n => {
          With
        },
        19n => {
          HasAttr
        },
        _ => {
          InvalidNode
        },
      }
    }

  }

  provide module Assert {
    @externalName("[constructor]assert")
    foreign wasm wit_bindgen_constructorAssert: (WasmI32, WasmI32, WasmI32, WasmI32) => WasmI32 from "spotandjake:snow/nix"

    @unsafe
    provide let constructor: (NixExpr, NixExpr) => Assert = (body, condition) => {
      let mut resultvariant_lower_0 = 0n
      let mut resultvariant_lower_1 = 0n
      match (body) {
        Apply(e) => {
          resultvariant_lower_0 = 0n
          resultvariant_lower_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Assert(e) => {
          resultvariant_lower_0 = 1n
          resultvariant_lower_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Error => {
          resultvariant_lower_0 = 2n
          resultvariant_lower_1 = 0n
        },
        IfElse(e) => {
          resultvariant_lower_0 = 3n
          resultvariant_lower_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Select => {
          resultvariant_lower_0 = 4n
          resultvariant_lower_1 = 0n
        },
        Str => {
          resultvariant_lower_0 = 5n
          resultvariant_lower_1 = 0n
        },
        Path => {
          resultvariant_lower_0 = 6n
          resultvariant_lower_1 = 0n
        },
        Literal => {
          resultvariant_lower_0 = 7n
          resultvariant_lower_1 = 0n
        },
        Lambda => {
          resultvariant_lower_0 = 8n
          resultvariant_lower_1 = 0n
        },
        LegacyLet => {
          resultvariant_lower_0 = 9n
          resultvariant_lower_1 = 0n
        },
        LetIn => {
          resultvariant_lower_0 = 10n
          resultvariant_lower_1 = 0n
        },
        List => {
          resultvariant_lower_0 = 11n
          resultvariant_lower_1 = 0n
        },
        BinOp => {
          resultvariant_lower_0 = 12n
          resultvariant_lower_1 = 0n
        },
        Paren => {
          resultvariant_lower_0 = 13n
          resultvariant_lower_1 = 0n
        },
        Root => {
          resultvariant_lower_0 = 14n
          resultvariant_lower_1 = 0n
        },
        AttrSet(e) => {
          resultvariant_lower_0 = 15n
          resultvariant_lower_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        UnaryOp => {
          resultvariant_lower_0 = 16n
          resultvariant_lower_1 = 0n
        },
        Ident => {
          resultvariant_lower_0 = 17n
          resultvariant_lower_1 = 0n
        },
        With => {
          resultvariant_lower_0 = 18n
          resultvariant_lower_1 = 0n
        },
        HasAttr => {
          resultvariant_lower_0 = 19n
          resultvariant_lower_1 = 0n
        },
        InvalidNode => {
          resultvariant_lower_0 = 20n
          resultvariant_lower_1 = 0n
        },
      }
      let mut resultvariant_lower0_0 = 0n
      let mut resultvariant_lower0_1 = 0n
      match (condition) {
        Apply(e) => {
          resultvariant_lower0_0 = 0n
          resultvariant_lower0_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Assert(e) => {
          resultvariant_lower0_0 = 1n
          resultvariant_lower0_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Error => {
          resultvariant_lower0_0 = 2n
          resultvariant_lower0_1 = 0n
        },
        IfElse(e) => {
          resultvariant_lower0_0 = 3n
          resultvariant_lower0_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Select => {
          resultvariant_lower0_0 = 4n
          resultvariant_lower0_1 = 0n
        },
        Str => {
          resultvariant_lower0_0 = 5n
          resultvariant_lower0_1 = 0n
        },
        Path => {
          resultvariant_lower0_0 = 6n
          resultvariant_lower0_1 = 0n
        },
        Literal => {
          resultvariant_lower0_0 = 7n
          resultvariant_lower0_1 = 0n
        },
        Lambda => {
          resultvariant_lower0_0 = 8n
          resultvariant_lower0_1 = 0n
        },
        LegacyLet => {
          resultvariant_lower0_0 = 9n
          resultvariant_lower0_1 = 0n
        },
        LetIn => {
          resultvariant_lower0_0 = 10n
          resultvariant_lower0_1 = 0n
        },
        List => {
          resultvariant_lower0_0 = 11n
          resultvariant_lower0_1 = 0n
        },
        BinOp => {
          resultvariant_lower0_0 = 12n
          resultvariant_lower0_1 = 0n
        },
        Paren => {
          resultvariant_lower0_0 = 13n
          resultvariant_lower0_1 = 0n
        },
        Root => {
          resultvariant_lower0_0 = 14n
          resultvariant_lower0_1 = 0n
        },
        AttrSet(e) => {
          resultvariant_lower0_0 = 15n
          resultvariant_lower0_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        UnaryOp => {
          resultvariant_lower0_0 = 16n
          resultvariant_lower0_1 = 0n
        },
        Ident => {
          resultvariant_lower0_0 = 17n
          resultvariant_lower0_1 = 0n
        },
        With => {
          resultvariant_lower0_0 = 18n
          resultvariant_lower0_1 = 0n
        },
        HasAttr => {
          resultvariant_lower0_0 = 19n
          resultvariant_lower0_1 = 0n
        },
        InvalidNode => {
          resultvariant_lower0_0 = 20n
          resultvariant_lower0_1 = 0n
        },
      }
      let ret = wit_bindgen_constructorAssert(resultvariant_lower_0, resultvariant_lower_1, resultvariant_lower0_0, resultvariant_lower0_1)
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: Assert
      handle_lift
    }


    @externalName("[method]assert.get-body")
    foreign wasm wit_bindgen_methodAssert_getBody: (WasmI32, WasmI32) => Void from "spotandjake:snow/nix"

    @unsafe
    provide let getBody: (Assert) => NixExpr = (self) => {
      wit_bindgen_methodAssert_getBody(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: Apply
          Apply(handle_lift)
        },
        1n => {
          let handle_lift0 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: Assert
          Assert(handle_lift0)
        },
        2n => {
          Error
        },
        3n => {
          let handle_lift1 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: IfElse
          IfElse(handle_lift1)
        },
        4n => {
          Select
        },
        5n => {
          Str
        },
        6n => {
          Path
        },
        7n => {
          Literal
        },
        8n => {
          Lambda
        },
        9n => {
          LegacyLet
        },
        10n => {
          LetIn
        },
        11n => {
          List
        },
        12n => {
          BinOp
        },
        13n => {
          Paren
        },
        14n => {
          Root
        },
        15n => {
          let handle_lift2 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: AttrSet
          AttrSet(handle_lift2)
        },
        16n => {
          UnaryOp
        },
        17n => {
          Ident
        },
        18n => {
          With
        },
        19n => {
          HasAttr
        },
        _ => {
          InvalidNode
        },
      }
    }


    @externalName("[method]assert.get-condition")
    foreign wasm wit_bindgen_methodAssert_getCondition: (WasmI32, WasmI32) => Void from "spotandjake:snow/nix"

    @unsafe
    provide let getCondition: (Assert) => NixExpr = (self) => {
      wit_bindgen_methodAssert_getCondition(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: Apply
          Apply(handle_lift)
        },
        1n => {
          let handle_lift0 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: Assert
          Assert(handle_lift0)
        },
        2n => {
          Error
        },
        3n => {
          let handle_lift1 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: IfElse
          IfElse(handle_lift1)
        },
        4n => {
          Select
        },
        5n => {
          Str
        },
        6n => {
          Path
        },
        7n => {
          Literal
        },
        8n => {
          Lambda
        },
        9n => {
          LegacyLet
        },
        10n => {
          LetIn
        },
        11n => {
          List
        },
        12n => {
          BinOp
        },
        13n => {
          Paren
        },
        14n => {
          Root
        },
        15n => {
          let handle_lift2 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: AttrSet
          AttrSet(handle_lift2)
        },
        16n => {
          UnaryOp
        },
        17n => {
          Ident
        },
        18n => {
          With
        },
        19n => {
          HasAttr
        },
        _ => {
          InvalidNode
        },
      }
    }

  }

  provide module IfElse {
    @externalName("[constructor]if-else")
    foreign wasm wit_bindgen_constructorIfElse: (WasmI32, WasmI32, WasmI32, WasmI32, WasmI32, WasmI32) => WasmI32 from "spotandjake:snow/nix"

    @unsafe
    provide let constructor: (NixExpr, NixExpr, NixExpr) => IfElse = (condition, body, elseBody) => {
      let mut resultvariant_lower_0 = 0n
      let mut resultvariant_lower_1 = 0n
      match (condition) {
        Apply(e) => {
          resultvariant_lower_0 = 0n
          resultvariant_lower_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Assert(e) => {
          resultvariant_lower_0 = 1n
          resultvariant_lower_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Error => {
          resultvariant_lower_0 = 2n
          resultvariant_lower_1 = 0n
        },
        IfElse(e) => {
          resultvariant_lower_0 = 3n
          resultvariant_lower_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Select => {
          resultvariant_lower_0 = 4n
          resultvariant_lower_1 = 0n
        },
        Str => {
          resultvariant_lower_0 = 5n
          resultvariant_lower_1 = 0n
        },
        Path => {
          resultvariant_lower_0 = 6n
          resultvariant_lower_1 = 0n
        },
        Literal => {
          resultvariant_lower_0 = 7n
          resultvariant_lower_1 = 0n
        },
        Lambda => {
          resultvariant_lower_0 = 8n
          resultvariant_lower_1 = 0n
        },
        LegacyLet => {
          resultvariant_lower_0 = 9n
          resultvariant_lower_1 = 0n
        },
        LetIn => {
          resultvariant_lower_0 = 10n
          resultvariant_lower_1 = 0n
        },
        List => {
          resultvariant_lower_0 = 11n
          resultvariant_lower_1 = 0n
        },
        BinOp => {
          resultvariant_lower_0 = 12n
          resultvariant_lower_1 = 0n
        },
        Paren => {
          resultvariant_lower_0 = 13n
          resultvariant_lower_1 = 0n
        },
        Root => {
          resultvariant_lower_0 = 14n
          resultvariant_lower_1 = 0n
        },
        AttrSet(e) => {
          resultvariant_lower_0 = 15n
          resultvariant_lower_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        UnaryOp => {
          resultvariant_lower_0 = 16n
          resultvariant_lower_1 = 0n
        },
        Ident => {
          resultvariant_lower_0 = 17n
          resultvariant_lower_1 = 0n
        },
        With => {
          resultvariant_lower_0 = 18n
          resultvariant_lower_1 = 0n
        },
        HasAttr => {
          resultvariant_lower_0 = 19n
          resultvariant_lower_1 = 0n
        },
        InvalidNode => {
          resultvariant_lower_0 = 20n
          resultvariant_lower_1 = 0n
        },
      }
      let mut resultvariant_lower0_0 = 0n
      let mut resultvariant_lower0_1 = 0n
      match (body) {
        Apply(e) => {
          resultvariant_lower0_0 = 0n
          resultvariant_lower0_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Assert(e) => {
          resultvariant_lower0_0 = 1n
          resultvariant_lower0_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Error => {
          resultvariant_lower0_0 = 2n
          resultvariant_lower0_1 = 0n
        },
        IfElse(e) => {
          resultvariant_lower0_0 = 3n
          resultvariant_lower0_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Select => {
          resultvariant_lower0_0 = 4n
          resultvariant_lower0_1 = 0n
        },
        Str => {
          resultvariant_lower0_0 = 5n
          resultvariant_lower0_1 = 0n
        },
        Path => {
          resultvariant_lower0_0 = 6n
          resultvariant_lower0_1 = 0n
        },
        Literal => {
          resultvariant_lower0_0 = 7n
          resultvariant_lower0_1 = 0n
        },
        Lambda => {
          resultvariant_lower0_0 = 8n
          resultvariant_lower0_1 = 0n
        },
        LegacyLet => {
          resultvariant_lower0_0 = 9n
          resultvariant_lower0_1 = 0n
        },
        LetIn => {
          resultvariant_lower0_0 = 10n
          resultvariant_lower0_1 = 0n
        },
        List => {
          resultvariant_lower0_0 = 11n
          resultvariant_lower0_1 = 0n
        },
        BinOp => {
          resultvariant_lower0_0 = 12n
          resultvariant_lower0_1 = 0n
        },
        Paren => {
          resultvariant_lower0_0 = 13n
          resultvariant_lower0_1 = 0n
        },
        Root => {
          resultvariant_lower0_0 = 14n
          resultvariant_lower0_1 = 0n
        },
        AttrSet(e) => {
          resultvariant_lower0_0 = 15n
          resultvariant_lower0_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        UnaryOp => {
          resultvariant_lower0_0 = 16n
          resultvariant_lower0_1 = 0n
        },
        Ident => {
          resultvariant_lower0_0 = 17n
          resultvariant_lower0_1 = 0n
        },
        With => {
          resultvariant_lower0_0 = 18n
          resultvariant_lower0_1 = 0n
        },
        HasAttr => {
          resultvariant_lower0_0 = 19n
          resultvariant_lower0_1 = 0n
        },
        InvalidNode => {
          resultvariant_lower0_0 = 20n
          resultvariant_lower0_1 = 0n
        },
      }
      let mut resultvariant_lower1_0 = 0n
      let mut resultvariant_lower1_1 = 0n
      match (elseBody) {
        Apply(e) => {
          resultvariant_lower1_0 = 0n
          resultvariant_lower1_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Assert(e) => {
          resultvariant_lower1_0 = 1n
          resultvariant_lower1_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Error => {
          resultvariant_lower1_0 = 2n
          resultvariant_lower1_1 = 0n
        },
        IfElse(e) => {
          resultvariant_lower1_0 = 3n
          resultvariant_lower1_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        Select => {
          resultvariant_lower1_0 = 4n
          resultvariant_lower1_1 = 0n
        },
        Str => {
          resultvariant_lower1_0 = 5n
          resultvariant_lower1_1 = 0n
        },
        Path => {
          resultvariant_lower1_0 = 6n
          resultvariant_lower1_1 = 0n
        },
        Literal => {
          resultvariant_lower1_0 = 7n
          resultvariant_lower1_1 = 0n
        },
        Lambda => {
          resultvariant_lower1_0 = 8n
          resultvariant_lower1_1 = 0n
        },
        LegacyLet => {
          resultvariant_lower1_0 = 9n
          resultvariant_lower1_1 = 0n
        },
        LetIn => {
          resultvariant_lower1_0 = 10n
          resultvariant_lower1_1 = 0n
        },
        List => {
          resultvariant_lower1_0 = 11n
          resultvariant_lower1_1 = 0n
        },
        BinOp => {
          resultvariant_lower1_0 = 12n
          resultvariant_lower1_1 = 0n
        },
        Paren => {
          resultvariant_lower1_0 = 13n
          resultvariant_lower1_1 = 0n
        },
        Root => {
          resultvariant_lower1_0 = 14n
          resultvariant_lower1_1 = 0n
        },
        AttrSet(e) => {
          resultvariant_lower1_0 = 15n
          resultvariant_lower1_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        UnaryOp => {
          resultvariant_lower1_0 = 16n
          resultvariant_lower1_1 = 0n
        },
        Ident => {
          resultvariant_lower1_0 = 17n
          resultvariant_lower1_1 = 0n
        },
        With => {
          resultvariant_lower1_0 = 18n
          resultvariant_lower1_1 = 0n
        },
        HasAttr => {
          resultvariant_lower1_0 = 19n
          resultvariant_lower1_1 = 0n
        },
        InvalidNode => {
          resultvariant_lower1_0 = 20n
          resultvariant_lower1_1 = 0n
        },
      }
      let ret = wit_bindgen_constructorIfElse(resultvariant_lower_0, resultvariant_lower_1, resultvariant_lower0_0, resultvariant_lower0_1, resultvariant_lower1_0, resultvariant_lower1_1)
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: IfElse
      handle_lift
    }


    @externalName("[method]if-else.get-condition")
    foreign wasm wit_bindgen_methodIfElse_getCondition: (WasmI32, WasmI32) => Void from "spotandjake:snow/nix"

    @unsafe
    provide let getCondition: (IfElse) => NixExpr = (self) => {
      wit_bindgen_methodIfElse_getCondition(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: Apply
          Apply(handle_lift)
        },
        1n => {
          let handle_lift0 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: Assert
          Assert(handle_lift0)
        },
        2n => {
          Error
        },
        3n => {
          let handle_lift1 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: IfElse
          IfElse(handle_lift1)
        },
        4n => {
          Select
        },
        5n => {
          Str
        },
        6n => {
          Path
        },
        7n => {
          Literal
        },
        8n => {
          Lambda
        },
        9n => {
          LegacyLet
        },
        10n => {
          LetIn
        },
        11n => {
          List
        },
        12n => {
          BinOp
        },
        13n => {
          Paren
        },
        14n => {
          Root
        },
        15n => {
          let handle_lift2 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: AttrSet
          AttrSet(handle_lift2)
        },
        16n => {
          UnaryOp
        },
        17n => {
          Ident
        },
        18n => {
          With
        },
        19n => {
          HasAttr
        },
        _ => {
          InvalidNode
        },
      }
    }


    @externalName("[method]if-else.get-body")
    foreign wasm wit_bindgen_methodIfElse_getBody: (WasmI32, WasmI32) => Void from "spotandjake:snow/nix"

    @unsafe
    provide let getBody: (IfElse) => NixExpr = (self) => {
      wit_bindgen_methodIfElse_getBody(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: Apply
          Apply(handle_lift)
        },
        1n => {
          let handle_lift0 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: Assert
          Assert(handle_lift0)
        },
        2n => {
          Error
        },
        3n => {
          let handle_lift1 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: IfElse
          IfElse(handle_lift1)
        },
        4n => {
          Select
        },
        5n => {
          Str
        },
        6n => {
          Path
        },
        7n => {
          Literal
        },
        8n => {
          Lambda
        },
        9n => {
          LegacyLet
        },
        10n => {
          LetIn
        },
        11n => {
          List
        },
        12n => {
          BinOp
        },
        13n => {
          Paren
        },
        14n => {
          Root
        },
        15n => {
          let handle_lift2 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: AttrSet
          AttrSet(handle_lift2)
        },
        16n => {
          UnaryOp
        },
        17n => {
          Ident
        },
        18n => {
          With
        },
        19n => {
          HasAttr
        },
        _ => {
          InvalidNode
        },
      }
    }


    @externalName("[method]if-else.get-else-body")
    foreign wasm wit_bindgen_methodIfElse_getElseBody: (WasmI32, WasmI32) => Void from "spotandjake:snow/nix"

    @unsafe
    provide let getElseBody: (IfElse) => NixExpr = (self) => {
      wit_bindgen_methodIfElse_getElseBody(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: Apply
          Apply(handle_lift)
        },
        1n => {
          let handle_lift0 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: Assert
          Assert(handle_lift0)
        },
        2n => {
          Error
        },
        3n => {
          let handle_lift1 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: IfElse
          IfElse(handle_lift1)
        },
        4n => {
          Select
        },
        5n => {
          Str
        },
        6n => {
          Path
        },
        7n => {
          Literal
        },
        8n => {
          Lambda
        },
        9n => {
          LegacyLet
        },
        10n => {
          LetIn
        },
        11n => {
          List
        },
        12n => {
          BinOp
        },
        13n => {
          Paren
        },
        14n => {
          Root
        },
        15n => {
          let handle_lift2 = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: AttrSet
          AttrSet(handle_lift2)
        },
        16n => {
          UnaryOp
        },
        17n => {
          Ident
        },
        18n => {
          With
        },
        19n => {
          HasAttr
        },
        _ => {
          InvalidNode
        },
      }
    }

  }

  provide module AttrSet {
    @externalName("[constructor]attr-set")
    foreign wasm wit_bindgen_constructorAttrSet: () => WasmI32 from "spotandjake:snow/nix"

    @unsafe
    provide let constructor: () => AttrSet = () => {
      let ret = wit_bindgen_constructorAttrSet()
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: AttrSet
      handle_lift
    }

  }
}

