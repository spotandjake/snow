package spotandjake:snow;

interface nix {
    record text-range {
        start: u32,
        end: u32,
    }
    enum syntax-token {
        // Internals
        token-comment,
        token-error,
        token-whitespace,

        // Keywords
        token-assert,
        token-else,
        token-if,
        token-in,
        token-inherit,
        token-let,
        token-or,
        token-rec,
        token-then,
        token-with,

        // Symbols
        token-l-brace,
        token-r-brace,
        token-l-brack,
        token-r-brack,
        token-assign,
        token-at,
        token-colon,
        token-comma,
        token-dot,
        token-ellipsis,
        token-question,
        token-semicolon,

        // Operators
        token-l-paren,
        token-r-paren,
        token-concat,
        token-invert,
        token-update,

        token-add,
        token-sub,
        token-mul,
        token-div,

        token-and-and,
        token-equal,
        token-implication,
        token-less,
        token-less-or-eq,
        token-more,
        token-more-or-eq,
        token-not-equal,
        token-or-or,

        // Identifiers and values
        token-float,
        token-ident,
        token-integer,
        token-interpol-end,
        token-interpol-start,
        token-path,
        token-uri,
        token-string-content,
        token-string-end,
        token-string-start,

        node-apply,
        node-assert,
        node-attrpath,
        node-dynamic,
        node-error,
        node-ident,
        node-if-else,
        node-select,
        node-inherit,
        node-inherit-from,
        node-string,
        node-interpol,
        node-lambda,
        node-ident-param,
        // An old let { x = 92; body = x; } syntax
        node-legacy-let,
        node-let-in,
        node-list,
        node-bin-op,
        node-paren,
        node-pattern,
        node-pat-bind,
        node-pat-entry,
        node-root,
        node-attr-set,
        node-attrpath-value,
        node-unary-op,
        node-literal,
        node-with,
        node-path,
        // Attrpath existence check: foo ? bar.${baz}."bux"
        node-has-attr,

        last
    }
    variant nix-expr {
        apply(apply),
        assert(assert),
        error,
        if-else(if-else),
        select,
        str,
        path,
        literal,
        lambda,
        legacy-let,
        let-in,
        %list,
        bin-op,
        paren,
        root,
        attr-set(attr-set),
        unary-op,
        ident,
        %with,
        has-attr,
        invalid-node,
    }
    resource apply {
        constructor(arg: nix-expr, lambda: nix-expr);
        get-argument: func() -> nix-expr;
        get-lambda: func() -> nix-expr;
    }
    resource assert {
        constructor(body: nix-expr, condition: nix-expr);
        get-body: func() -> nix-expr;
        get-condition: func() -> nix-expr;
    }
    resource if-else {
        constructor(condition: nix-expr, body: nix-expr, else-body: nix-expr);
        get-condition: func() -> nix-expr;
        get-body: func() -> nix-expr;
        get-else-body: func() -> nix-expr;
    }
    // TODO: select,
    // TODO: str,
    // TODO: path,
    // TODO: literal,
    // TODO: lambda,
    // TODO: legacy-let,
    // TODO: let-in,
    // TODO: %list,
    // TODO: bin-op,
    // TODO: paren,
    // TODO: root,
    resource attr-set {
        constructor();
    }
    // TODO: unary-op,
    // TODO: ident,
    // TODO: %with,
    // TODO: has-attr,
    // TODO: invalid-node,
    variant nix-parse-error {
        /// Unexpected is used when the cause cannot be specified further
        unexpected(text-range),
        /// UnexpectedExtra is used when there are additional tokens to the root in the tree
        unexpected-extra(text-range),
        /// UnexpectedWanted is used when specific tokens are expected, but different one is found
        unexpected-wanted(tuple<syntax-token, text-range, list<syntax-token>>),
        /// UnexpectedDoubleBind is used when a pattern is bound twice
        unexpected-double-bind(text-range),
        /// UnexpectedEOF is used when the end of file is reached, while tokens are still expected
        unexpected-eof,
        /// UnexpectedEOFWanted is used when specific tokens are expected, but the end of file is reached
        unexpected-eof-wanted(list<syntax-token>),
        /// DuplicatedArgs is used when formal arguments are duplicated, e.g. `{ a, a }`
        duplicated-args(tuple<text-range, string>),
        /// RecursionLimitExceeded is used when we're unable to parse further due to likely being close to
        /// a stack overflow.
        recursion-limit-exceeded,
        /// Occurs when an unknown error is encountered
        unknown,
    }
    parse: func(nix-source: string) -> result<nix-expr, nix-parse-error>;
}

world rnix {
    export nix;
}